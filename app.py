#!/usr/bin/env python3
"""
app.py - SSRVM Flask app (full updated version)

Features:
- All chatbot replies are generated by Google Gemini (Generative) API when available.
- Immediate local crisis detection: automatically logs a counsellor request and
  attempts to notify counsellors via SMTP email and/or webhook (no user click required).
- Notification attempts are recorded in a `notifications` table for audit.
- Uses environment variables for all secrets (no hardcoding).
- Keeps local fallback behavior for other pages (journals, CBT, dashboard, etc.)

Environment variables you may set:
- GEMINI_API_KEY         (optional; if not set, fallback messages are used)
- GEMINI_MODEL          (optional, default "text-bison-001")
- SMTP_HOST             (optional)
- SMTP_PORT             (optional, e.g. 587)
- SMTP_USER             (optional)
- SMTP_PASS             (optional)
- COUNSELLOR_EMAIL      (optional)
- COUNSELLOR_WEBHOOK    (optional)
- SSRVM_SECRET          (optional, Flask secret)
- SSRVM_DEBUG_NOTIFY=1  (optional, include debug notify details in JSON responses - only for dev)

Install dependencies:
    pip install flask requests

Run:
    export GEMINI_API_KEY="your_api_key_here"
    python app.py
"""
import os
import re
import json
import sqlite3
import csv
import smtplib
import requests
from email.message import EmailMessage
from datetime import datetime, timezone
import random
from flask import (
    Flask, render_template, request, redirect, url_for, session,
    flash, send_file, jsonify
)

# ---------------- App config ----------------
APP_NAME = "SSRVM-BE"
SECRET = os.environ.get("SSRVM_SECRET", "dev-secret-change-me")
app = Flask(__name__)
app.secret_key = SECRET

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, "data")
os.makedirs(DATA_DIR, exist_ok=True)
DB_PATH = os.path.join(DATA_DIR, "ssrvm.db")

# ---------------- DB helpers ----------------
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

def get_db():
    conn = sqlite3.connect(DB_PATH, timeout=10, check_same_thread=False)
    conn.row_factory = dict_factory
    return conn

def init_db():
    conn = get_db()
    cur = conn.cursor()
    cur.executescript("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        is_admin INTEGER DEFAULT 0
    );

    CREATE TABLE IF NOT EXISTS journals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        content TEXT NOT NULL,
        created_at TEXT DEFAULT (datetime('now', 'localtime')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS counsellor_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        message TEXT,
        want_counsellor INTEGER DEFAULT 0,
        auto_notify INTEGER DEFAULT 0,
        resolved INTEGER DEFAULT 0,
        created_at TEXT DEFAULT (datetime('now', 'localtime')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS notifications (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        counsellor_request_id INTEGER,
        user_id INTEGER,
        channel TEXT,
        success INTEGER DEFAULT 0,
        details TEXT,
        created_at TEXT DEFAULT (datetime('now', 'localtime'))
    );
    """)
    conn.commit()
    conn.close()

init_db()

# ---------------- Local helpers ----------------
PROMPTS = [
    "What drained your energy today?",
    "Who or what made you smile today?",
    "What is something you are grateful for?",
    "What is one thing you want to improve emotionally?",
    "What felt overwhelming today?",
]

QUOTES = [
    "You are stronger than you think.",
    "One step at a time.",
    "Your feelings are valid.",
    "You are enough.",
    "Everything will be okay.",
]

NEG_WORDS = set("stressed anxious panic hopeless sad depressed overwhelmed guilty ashamed angry lonely tired exhausted worthless failure fear worry uneasy scared exam pressure burnout".split())
POS_WORDS = set("calm proud grateful hopeful happy excited relaxed content confident okay fine better improving".split())

def quick_sentiment(text: str):
    text = (text or "").lower()
    neg = sum(1 for w in NEG_WORDS if w in text)
    pos = sum(1 for w in POS_WORDS if w in text)
    return pos - neg

def emotion_summary(user_id):
    conn = get_db()
    cur = conn.cursor()
    cur.execute("SELECT content FROM journals WHERE user_id=?", (user_id,))
    rows = cur.fetchall() or []
    conn.close()
    text = " ".join(r["content"].lower() for r in rows)
    cluster = {
        "stress": ["stress","overwhelmed","anxious","exam","pressure"],
        "sad": ["sad","lonely","tired","upset","down"],
        "anger": ["angry","frustrated","irritated"],
        "positive": ["happy","proud","good","hopeful","calm"]
    }
    score = {k:0 for k in cluster}
    for cat, words in cluster.items():
        for w in words:
            score[cat] += text.count(w)
    summary = ""
    if score["stress"]>0: summary += "There are signs of stress or exam pressure. "
    if score["sad"]>0: summary += "Some entries show sadness or emotional fatigue. "
    if score["anger"]>0: summary += "A few moments of frustration or irritation were noted. "
    if score["positive"]>0: summary += "You also showed hopeful or positive moments. "
    if summary == "": summary = "No strong emotional patterns detected. Keep journaling regularly."
    return summary

def current_user():
    return session.get("user")

# ---------------- Notification helper ----------------
def notify_counsellor(user: dict, message_text: str, counsellor_request_id: int = None):
    """
    Attempt to notify counsellor via SMTP and/or webhook.
    Returns a list of notification outcomes as dicts:
      [{"channel": "email", "success": True, "details": "..."}, ...]
    Records entries in notifications table.
    """
    outcomes = []

    # EMAIL notification if configured
    smtp_host = os.environ.get("SMTP_HOST")
    smtp_port = int(os.environ.get("SMTP_PORT", "587")) if os.environ.get("SMTP_PORT") else None
    smtp_user = os.environ.get("SMTP_USER")
    smtp_pass = os.environ.get("SMTP_PASS")
    counsellor_email = os.environ.get("COUNSELLOR_EMAIL")

    if smtp_host and smtp_port and smtp_user and smtp_pass and counsellor_email:
        try:
            subject = f"[SSRVM] Crisis alert — {user.get('name','Unknown')} (id={user.get('id')})"
            body = (
                f"Student: {user.get('name')} <{user.get('email')}>\n"
                f"User ID: {user.get('id')}\n"
                f"Time: {datetime.now(timezone.utc).isoformat()}\n\n"
                "Detected message:\n"
                f"{message_text}\n\n"
                "This message was automatically flagged as an urgent counsellor notification by SSRVM.\n"
                "Please follow your normal outreach/triage procedures right away."
            )
            msg = EmailMessage()
            msg["From"] = smtp_user
            msg["To"] = counsellor_email
            msg["Subject"] = subject
            msg.set_content(body)

            server = smtplib.SMTP(smtp_host, smtp_port, timeout=10)
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            server.quit()
            outcomes.append({"channel": "email", "success": True, "details": "email sent"})
        except Exception as e:
            outcomes.append({"channel": "email", "success": False, "details": str(e)})

    # WEBHOOK notification if configured
    webhook = os.environ.get("COUNSELLOR_WEBHOOK")
    if webhook:
        try:
            payload = {
                "text": f"SSRVM Crisis alert for student: {user.get('name')} (id={user.get('id')})",
                "student": {"id": user.get("id"), "name": user.get("name"), "email": user.get("email")},
                "message": message_text,
                "time": datetime.now(timezone.utc).isoformat()
            }
            resp = requests.post(webhook, json=payload, timeout=8)
            if 200 <= resp.status_code < 300:
                outcomes.append({"channel": "webhook", "success": True, "details": f"http {resp.status_code}"})
            else:
                outcomes.append({"channel": "webhook", "success": False, "details": f"http {resp.status_code}: {resp.text[:200]}"})
        except Exception as e:
            outcomes.append({"channel": "webhook", "success": False, "details": str(e)})

    # Persist notification attempts in notifications table
    try:
        conn = get_db()
        cur = conn.cursor()
        for o in outcomes:
            cur.execute(
                "INSERT INTO notifications (counsellor_request_id, user_id, channel, success, details) VALUES (?, ?, ?, ?, ?)",
                (counsellor_request_id, user.get("id"), o["channel"], 1 if o["success"] else 0, json.dumps(o["details"]) if isinstance(o["details"], (dict,list)) else str(o["details"]))
            )
        conn.commit()
        conn.close()
    except Exception:
        # do not raise; we want to continue even if logging fails
        pass

    return outcomes

# ---------------- Gemini integration (optional) ----------------
def analyze_with_gemini_generate(text: str):
    """
    Send text to Google Gemini (Generative) API and parse a JSON reply.
    Expected returned dict must contain at least: 'reply' (string).
    Also may include 'score' (float) and 'risk' (bool).
    Returns dict or None on failure.
    """
    try:
        import requests
    except Exception:
        return None

    api_key = os.environ.get("GEMINI_API_KEY")
    if not api_key:
        return None

    model = os.environ.get("GEMINI_MODEL", "text-bison-001")
    url = f"https://generativelanguage.googleapis.com/v1beta2/models/{model}:generate?key={api_key}"

    prompt = (
        "You are a warm, empathetic student-support assistant. Given the user's text, "
        "produce a JSON object ONLY (no explanation) with these fields:\n"
        "  - reply: the assistant's reply text (empathetic, supportive, concise)\n"
        "  - score: sentiment score between -1.0 and 1.0 (negative to positive)\n"
        "  - summary: one-line summary of detected feelings (optional)\n"
        "  - risk: true/false when self-harm/suicide risk is present\n"
        f"User text: '''{text}'''\n"
    )

    payload = {
        "prompt": {"text": prompt},
        "temperature": 0.0,
        "maxOutputTokens": 512,
    }
    headers = {"Content-Type": "application/json"}

    try:
        resp = requests.post(url, headers=headers, json=payload, timeout=15)
        if resp.status_code != 200:
            return None
        data = resp.json()

        # Extract textual content
        out = ""
        if isinstance(data, dict):
            if "candidates" in data and data["candidates"]:
                cand = data["candidates"][0]
                if isinstance(cand, dict):
                    out = cand.get("content") or cand.get("output") or ""
                else:
                    out = str(cand)
            elif "output" in data and isinstance(data["output"], list):
                parts = []
                for o in data["output"]:
                    if isinstance(o, dict) and "content" in o:
                        parts.append(o["content"])
                    else:
                        parts.append(str(o))
                out = "\n".join(parts)
            elif "text" in data:
                out = data["text"]
            else:
                out = json.dumps(data)
        else:
            out = str(data)

        # Find JSON object in output
        m = re.search(r"\{[\s\S]*\}", out)
        if m:
            parsed = json.loads(m.group(0))
            # normalize fields
            reply = str(parsed.get("reply", "")).strip()
            score = parsed.get("score", 0)
            try:
                score = float(score)
            except Exception:
                score = 0.0
            summary = str(parsed.get("summary", "")).strip() if parsed.get("summary") is not None else ""
            risk = bool(parsed.get("risk", False))
            return {"reply": reply, "score": score, "summary": summary, "risk": risk, "raw": parsed}

        # Fallback: line-parsing
        reply = ""
        score = None
        summary = ""
        risk = False
        for line in out.splitlines():
            if ":" in line:
                k, v = line.split(":", 1)
                k = k.strip().lower(); v = v.strip()
                if k == "reply" and not reply:
                    reply = v
                if k == "score" and score is None:
                    try:
                        score = float(re.findall(r"-?\d+\.?\d*", v)[0])
                    except Exception:
                        pass
                if k == "summary" and not summary:
                    summary = v
                if k == "risk":
                    risk = ("true" in v.lower()) or ("yes" in v.lower())
        if not reply and out.strip():
            reply = out.strip()
        if score is None:
            score = 0.0
        if not reply:
            return None
        return {"reply": reply, "score": float(score), "summary": summary, "risk": bool(risk), "raw": data}
    except Exception:
        return None

# ---------------- Local mentor (fallback small helper) ----------------
def mentor_reply(text: str):
    t = (text or "").strip()
    if not t:
        return ("I'm here for you. Tell me what's on your mind, I'm listening.", False)
    lower = t.lower()
    if "exam" in lower or "test" in lower:
        return ("Exam pressure is heavy. Try 25–5 study timer and plan your next tiny step.", True)
    if "panic" in lower or "anxiety" in lower:
        return ("Try 4–4–4 breathing: inhale 4s, hold 4s, exhale 4s. It really helps. I'm here.", True)
    if "lonely" in lower or "alone" in lower:
        return ("Feeling lonely is difficult. Try messaging someone you trust—even a small hello helps.", True)
    score = quick_sentiment(lower)
    if score < 0:
        return ("Thanks for telling me. I can help break this down into steps. Want counsellor support too?", True)
    return ("Got it. I can help with grounding or focus tools anytime.", False)

# ---------------- Immediate crisis phrases ----------------
CRISIS_PHRASES = ["kill myself","suicide","hurt myself","self harm","end my life","can't continue","want to die"]

# ---------------- Routes: pages, auth, etc. ----------------
@app.route("/")
def index():
    return render_template("index.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/signup", methods=["GET","POST"])
def signup():
    if request.method == "POST":
        name = request.form.get("name","").strip()
        email = request.form.get("email","").strip().lower()
        password = request.form.get("password","")
        if not (name and email and password):
            flash("Please fill all fields.")
            return redirect(url_for("signup"))
        conn = get_db(); cur = conn.cursor()
        try:
            cur.execute("INSERT INTO users(name,email,password) VALUES (?,?,?)", (name,email,password))
            conn.commit()
        except sqlite3.IntegrityError:
            conn.close(); flash("Email already exists."); return redirect(url_for("signup"))
        cur.execute("SELECT id,name,email,is_admin FROM users WHERE email=?", (email,)); u = cur.fetchone(); conn.close()
        session["user"] = {k: u[k] for k in ("id","name","email","is_admin")}
        return redirect(url_for("dashboard"))
    return render_template("signup.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/login", methods=["GET","POST"])
def login():
    if request.method == "POST":
        email = request.form.get("email","").strip().lower(); password = request.form.get("password","")
        # admin quick login (as requested)
        if email == "admin@ssrvm.com" and password == "admin123":
            session["user"] = {"id": 0, "name": "Counsellor", "email": "admin@ssrvm.com", "is_admin": 1}
            return redirect(url_for("admin"))
        conn = get_db(); cur = conn.cursor()
        cur.execute("SELECT id,name,email,password,is_admin FROM users WHERE email=?", (email,)); u = cur.fetchone(); conn.close()
        if not u or u["password"] != password:
            flash("Invalid credentials."); return redirect(url_for("login"))
        session["user"] = {k: u[k] for k in ("id","name","email","is_admin")}
        # redirect admins
        if session["user"].get("is_admin"):
            return redirect(url_for("admin"))
        return redirect(url_for("dashboard"))
    return render_template("login.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/logout")
def logout():
    session.clear(); flash("Logged out."); return redirect(url_for("index"))

@app.route("/dashboard")
def dashboard():
    if not current_user(): return redirect(url_for("login"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT want_counsellor, created_at FROM counsellor_requests WHERE user_id=? ORDER BY id DESC LIMIT 1", (current_user()["id"],))
    c_req = cur.fetchone(); conn.close()
    return render_template("dashboard.html", app_name=APP_NAME, counsellor_request=c_req,
                           prompt=random.choice(PROMPTS), quote=random.choice(QUOTES),
                           emotion_summary=emotion_summary(current_user()["id"]), year=datetime.now().year)

@app.route("/journal", methods=["GET","POST"])
def journal():
    if not current_user(): return redirect(url_for("login"))
    if request.method == "POST":
        content = request.form.get("content","").strip()
        if not content: flash("Write something."); return redirect(url_for("journal"))
        conn = get_db(); cur = conn.cursor()
        cur.execute("INSERT INTO journals(user_id,content) VALUES (?,?)", (current_user()["id"], content)); conn.commit(); conn.close()
        flash("Saved."); return redirect(url_for("journal"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT content,created_at FROM journals WHERE user_id=? ORDER BY id DESC LIMIT 20", (current_user()["id"],))
    entries = cur.fetchall(); conn.close()
    return render_template("journal.html", entries=entries, prompt=random.choice(PROMPTS), app_name=APP_NAME, year=datetime.now().year)

@app.route("/cbt", methods=["GET","POST"])
def cbt():
    if not current_user(): return redirect(url_for("login"))
    reframe = None
    if request.method == "POST":
        thought = request.form.get("thought","")
        def cbt_reframe(th):
            t = (th or "").lower()
            if not t: return "Describe the thought. Example: 'I always fail exams.'"
            patterns = [("always","Is it *always*? Look for exceptions."), ("never","Even one example shows it's not 'never'."), ("should","Try replacing 'should' with a kinder expectation."), ("must","Is this a preference instead of a strict rule?"), ("fail","One failure doesn't define your worth."), ("alone","Consider reaching out to someone trusted.")]
            for key,msg in patterns:
                if key in t: return f"It sounds tough. {msg} Try a softer reframe: 'I'm improving step by step.'"
            return "Try listing evidence for and against the thought. Balance helps."
        reframe = cbt_reframe(thought)
    return render_template("cbt.html", reframe=reframe, app_name=APP_NAME, year=datetime.now().year)

@app.route("/resources")
def resources():
    return render_template("resources.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/grounding")
def grounding():
    return render_template("grounding.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/profile")
def profile():
    if not current_user(): return redirect(url_for("login"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT message,want_counsellor,created_at FROM counsellor_requests WHERE user_id=? ORDER BY id DESC", (current_user()["id"],))
    reqs = cur.fetchall(); conn.close()
    return render_template("profile.html", app_name=APP_NAME, requests=reqs, year=datetime.now().year)

@app.route("/export-journal", methods=["POST"])
def export_journal():
    if not current_user(): return redirect(url_for("login"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT created_at, content FROM journals WHERE user_id=?", (current_user()["id"],))
    rows = cur.fetchall(); conn.close()
    out_path = os.path.join(DATA_DIR, f"journal_{current_user()['id']}.csv")
    with open(out_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f); writer.writerow(["created_at","content"])
        for r in rows: writer.writerow([r["created_at"], r["content"]])
    return send_file(out_path, as_attachment=True)

@app.route("/delete-account", methods=["POST"])
def delete_account():
    if not current_user(): return redirect(url_for("login"))
    uid = current_user()["id"]
    conn = get_db(); cur = conn.cursor()
    cur.execute("DELETE FROM journals WHERE user_id=?", (uid,))
    cur.execute("DELETE FROM counsellor_requests WHERE user_id=?", (uid,))
    cur.execute("DELETE FROM users WHERE id=?", (uid,))
    conn.commit(); conn.close(); session.clear(); flash("Account deleted.")
    return redirect(url_for("index"))

# ---------------- Chat endpoints (Gemini-driven replies + automatic notification on crisis) ----------------
@app.route("/chat")
def chat_page():
    if not current_user():
        return redirect(url_for("login"))
    return render_template("chatbot.html", app_name=APP_NAME, year=datetime.now().year)

# add alias endpoint 'chatbot' for template links elsewhere
app.add_url_rule('/chat', endpoint='chatbot', view_func=chat_page)

@app.route("/api/chatbot", methods=["POST"])
def api_chatbot():
    if not current_user():
        return jsonify({"error": "unauthorized"}), 401

    data = request.get_json() or {}
    text = (data.get("text", "") or "").strip()
    text_l = text.lower()

    # ---------------- CRISIS PHRASE DETECTION ----------------
    if any(p in text_l for p in CRISIS_PHRASES):
        try:
            conn = get_db()
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO counsellor_requests (user_id, message, want_counsellor, auto_notify) VALUES (?, ?, ?, ?)",
                (current_user()["id"], text, 1, 1)
            )
            counsellor_request_id = cur.lastrowid
            conn.commit()
            conn.close()
        except Exception:
            counsellor_request_id = None

        # Notify counsellor automatically
        notify_outcomes = notify_counsellor(current_user(), text, counsellor_request_id)

        # Crisis response
        reply_text = (
            "It sounds like you’re in serious distress. Please talk to someone you trust or reach out to your counsellor immediately. "
            "You are not alone — your counsellor/student support team has been notified and will reach out soon. "
            "If you’re in immediate danger, please contact local emergency services right away."
        )

        resp = {
            "reply": reply_text,
            "crisis": True,
            "notified": any(o.get("success") for o in notify_outcomes)
        }
        if os.environ.get("SSRVM_DEBUG_NOTIFY") == "1":
            resp["notify_debug"] = notify_outcomes
        return jsonify(resp), 200

    # ---------------- EMOTION-BASED REPLIES ----------------
    sadness_words = ["sad", "upset", "down", "hurt", "cry", "crying", "depressed"]
    anger_words = ["angry", "mad", "annoyed", "pissed", "frustrated", "irritated"]
    anxiety_words = ["anxious", "scared", "worried", "nervous", "panic", "panic attack"]
    overthinking_words = ["overthink", "overthinking", "thoughts won't stop", "can't stop thinking"]
    loneliness_words = ["lonely", "alone", "isolated"]
    stress_words = ["stressed", "pressure", "overwhelmed", "too much", "burnout"]

    if any(w in text_l for w in sadness_words):
        return jsonify({
            "reply": (
                "I’m really sorry you’re feeling this heavy. That kind of sadness can drain your energy. "
                "You’re not alone — I’m right here with you. "
                "Would grounding or a short breathing exercise help right now?"
            ),
            "ask_counsellor": True,
            "crisis": False
        }), 200

    if any(w in text_l for w in anger_words):
        return jsonify({
            "reply": (
                "It’s okay to feel angry — it usually means something important is happening inside you. "
                "You don’t have to hold it alone. "
                "Do you want help calming down, or do you want to talk about what triggered it?"
            ),
            "ask_counsellor": True,
            "crisis": False
        }), 200

    if any(w in text_l for w in anxiety_words):
        return jsonify({
            "reply": (
                "That sounds overwhelming. Anxiety can make everything feel heavier than it is. "
                "You’re safe here. Want to try a short breathing exercise together?"
            ),
            "ask_counsellor": True,
            "crisis": False
        }), 200

    if any(w in text_l for w in overthinking_words):
        return jsonify({
            "reply": (
                "Overthinking can trap you in loops that feel impossible to break. "
                "I’m here with you — you don’t have to fight your thoughts alone. "
                "Would a grounding technique help right now?"
            ),
            "ask_counsellor": True,
            "crisis": False
        }), 200

    if any(w in text_l for w in loneliness_words):
        return jsonify({
            "reply": (
                "Feeling lonely can hurt so much. I’m really glad you reached out instead of staying silent. "
                "You’re not alone here — I’m with you. "
                "Would you like to talk about what’s been making you feel this way?"
            ),
            "ask_counsellor": True,
            "crisis": False
        }), 200

    if any(w in text_l for w in stress_words):
        return jsonify({
            "reply": (
                "Feeling overwhelmed takes a lot out of you. You’re doing your best. "
                "Let’s take it one tiny step at a time. "
                "Would you like a small reset activity or grounding exercise?"
            ),
            "ask_counsellor": True,
            "crisis": False
        }), 200

    # ---------------- FALLBACK DISTRESS WORDS ----------------
    distress_keywords = [
        "stress", "stressed", "anxious", "panic", "hopeless", "sad",
        "depressed", "overwhelmed", "guilty", "ashamed", "angry",
        "lonely", "tired", "exhausted", "worthless", "fear", "worry",
        "uneasy", "scared", "pressure", "burnout"
    ]

    if any(word in text_l for word in distress_keywords):
        coping_suggestions = [
            "Try 4–4–4 breathing — inhale 4s, hold 4s, exhale 4s.",
            "Write your feelings in your journal. It often helps you understand your emotions.",
            "Take a short walk, drink some water, or listen to calming music.",
            "Reach out to someone you trust — even a small chat can make a difference.",
            "Remember to take things one step at a time. You’re doing your best."
        ]
        return jsonify({
            "reply": random.choice(coping_suggestions) +
                     " Would you like me to notify a counsellor so they can reach out to support you?",
            "ask_counsellor": True,
            "crisis": False
        }), 200

    # ---------------- YES / NO FOLLOW-UP HANDLERS ----------------
    yes_words = ["yes", "yeah", "yep", "sure", "ok", "okay", "yea", "yaa"]
    no_words = ["no", "nope", "nah", "na"]

    if text_l in yes_words:
        followups = [
            "Try a 4–4–4 breathing cycle: inhale 4s, hold 4s, exhale 4s. Want me to guide you?",
            "Here’s a grounding idea: name 5 things you can see. It helps bring your mind back.",
            "You're doing great. Try one slow deep breath… want another calming activity?",
            "Let's take it one step at a time — what part feels the heaviest right now?",
            "Put your hand on your chest and take 3 slow breaths. Want another soothing exercise?"
        ]
        return jsonify({
            "reply": random.choice(followups),
            "ask_counsellor": False,
            "crisis": False
        }), 200

    if text_l in no_words:
        return jsonify({
            "reply": "That's okay. I'm still right here with you. What would make things feel a little lighter?",
            "ask_counsellor": False,
            "crisis": False
        }), 200

    # ---------------- NORMAL GEMINI CHAT ----------------
    g = analyze_with_gemini_generate(text)

    if g is None:
        return jsonify({
            "reply": "I'm still here for you — tell me what’s been on your mind. The assistant service is temporarily unavailable, but you can keep sharing how you feel.",
            "error": "gemini_unavailable"
        }), 503

    reply = g.get("reply", "").strip() or "I'm here — tell me more."
    score = float(g.get("score", 0))
    risk = bool(g.get("risk", False))
    summary = g.get("summary", "") or ""

    response = {
        "reply": reply,
        "ask_counsellor": score < -0.3 or risk,
        "summary": summary,
        "score": score,
        "risk": risk
    }

    return jsonify(response), 200

@app.route("/api/counsellor-request", methods=["POST"])
def api_counsellor_request():
    if not current_user(): return jsonify({"error":"unauthorized"}), 401
    data = request.get_json() or {}
    want = 1 if data.get("want") else 0
    note = (data.get("note") or "").strip()
    conn = get_db(); cur = conn.cursor()
    cur.execute("INSERT INTO counsellor_requests(user_id,message,want_counsellor) VALUES (?,?,?)",
                (current_user()["id"], note, want)); conn.commit(); conn.close()
    return jsonify({"ok": True})

# ---------------- Admin ----------------
@app.route("/admin")
def admin():
    if not current_user(): return redirect(url_for("login"))
    cu = current_user()
    if not cu.get("is_admin") and cu.get("email") != "admin@ssrvm.com":
        return "Access denied", 403
    conn = get_db(); cur = conn.cursor()
    cur.execute("""SELECT cr.id, u.name, u.email, cr.message, cr.want_counsellor, cr.auto_notify, cr.resolved, cr.created_at
                   FROM counsellor_requests cr
                   LEFT JOIN users u ON u.id=cr.user_id
                   ORDER BY cr.id DESC""")
    rows = cur.fetchall(); conn.close()
    return render_template("admin.html", rows=rows, app_name=APP_NAME, year=datetime.now().year)

@app.context_processor
def inject_globals():
    return {"app_name": APP_NAME}

# ---------------- Run ----------------
if __name__ == "__main__":
    # ensure data dir and DB exist
    if not os.path.exists(os.path.dirname(DB_PATH)):
        try:
            os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
        except Exception:
            pass
    if not os.path.exists(DB_PATH):
        open(DB_PATH, "a").close()
    with app.app_context():
        init_db()
        # ensure a demo admin exists
        try:
            conn = get_db(); cur = conn.cursor()
            cur.execute("SELECT * FROM users WHERE email='admin@ssrvm.com'"); if_admin = cur.fetchone()
            if not if_admin:
                cur.execute("INSERT INTO users (name,email,password,is_admin) VALUES (?,?,?,?)",
                            ("Counsellor","admin@ssrvm.com","admin123",1))
                conn.commit()
            conn.close()
        except Exception:
            pass

    port = int(os.environ.get("PORT", 10000))
    debug = os.environ.get("FLASK_DEBUG", "1") == "1"
    app.run(host="0.0.0.0", port=port, debug=debug)
