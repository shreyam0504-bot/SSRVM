#!/usr/bin/env python3
"""
app.py - SSRVM Flask app (full updated version)

Features:
- All chatbot replies are generated by Google Gemini (Generative) API.
- Immediate local crisis detection: automatically logs a counsellor request and
  attempts to notify counsellors via SMTP email and/or webhook (no user click required).
- Notification attempts are recorded in a `notifications` table for audit.
- Uses environment variables for all secrets (no hardcoding).
- Keeps local fallback behavior for non-chat pages (journals, CBT, dashboard, etc.)

Environment variables you must set (examples):
- GEMINI_API_KEY         (required for chatbot replies)
- GEMINI_MODEL          (optional, default "text-bison-001")
- SMTP_HOST             (optional, if you want email notifications)
- SMTP_PORT             (optional, e.g. 587)
- SMTP_USER             (optional)
- SMTP_PASS             (optional)
- COUNSELLOR_EMAIL      (optional)
- COUNSELLOR_WEBHOOK    (optional)
- SSRVM_SECRET          (optional, Flask secret)
- SSRVM_DEBUG_NOTIFY=1  (optional, include debug notify details in JSON responses - only for dev)

Install dependencies:
    pip install flask requests

Run:
    export GEMINI_API_KEY="your_api_key_here"
    python app.py
"""

import os
import re
import json
import sqlite3
import csv
import smtplib
import requests
from email.message import EmailMessage
from datetime import datetime, timezone
import random

from flask import (
    Flask, render_template, request, redirect, url_for, session,
    flash, send_file, jsonify
)

# ---------------- App config ----------------
APP_NAME = "SSRVM"
SECRET = os.environ.get("SSRVM_SECRET", "dev-secret-change-me")
app = Flask(__name__)
app.secret_key = SECRET

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, "data")
os.makedirs(DATA_DIR, exist_ok=True)
DB_PATH = os.path.join(DATA_DIR, "ssrvm.db")

# ---------------- DB helpers ----------------
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

def get_db():
    conn = sqlite3.connect(DB_PATH, timeout=10, check_same_thread=False)
    conn.row_factory = dict_factory
    return conn

def init_db():
    conn = get_db()
    cur = conn.cursor()
    cur.executescript("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS journals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        content TEXT NOT NULL,
        created_at TEXT DEFAULT (datetime('now', 'localtime')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS counsellor_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        message TEXT,
        want_counsellor INTEGER DEFAULT 0,
        created_at TEXT DEFAULT (datetime('now', 'localtime')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS notifications (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        counsellor_request_id INTEGER,
        user_id INTEGER,
        channel TEXT,
        success INTEGER DEFAULT 0,
        details TEXT,
        created_at TEXT DEFAULT (datetime('now', 'localtime'))
    );
    """)
    conn.commit()
    conn.close()

init_db()

# ---------------- Local helpers ----------------
PROMPTS = [
    "What drained your energy today?",
    "Who or what made you smile today?",
    "What is something you are grateful for?",
    "What is one thing you want to improve emotionally?",
    "What felt overwhelming today?",
]

QUOTES = [
    "You are stronger than you think.",
    "One step at a time.",
    "Your feelings are valid.",
    "You are enough.",
    "Everything will be okay.",
]

NEG_WORDS = set("stressed anxious panic hopeless sad depressed overwhelmed guilty ashamed angry lonely tired exhausted worthless failure fear worry uneasy scared exam pressure burnout".split())
POS_WORDS = set("calm proud grateful hopeful happy excited relaxed content confident okay fine better improving".split())

def quick_sentiment(text: str):
    text = (text or "").lower()
    neg = sum(1 for w in NEG_WORDS if w in text)
    pos = sum(1 for w in POS_WORDS if w in text)
    return pos - neg

def emotion_summary(user_id):
    conn = get_db()
    cur = conn.cursor()
    cur.execute("SELECT content FROM journals WHERE user_id=?", (user_id,))
    rows = cur.fetchall() or []
    conn.close()
    text = " ".join(r["content"].lower() for r in rows)
    cluster = {
        "stress": ["stress","overwhelmed","anxious","exam","pressure"],
        "sad": ["sad","lonely","tired","upset","down"],
        "anger": ["angry","frustrated","irritated"],
        "positive": ["happy","proud","good","hopeful","calm"]
    }
    score = {k:0 for k in cluster}
    for cat, words in cluster.items():
        for w in words:
            score[cat] += text.count(w)
    summary = ""
    if score["stress"]>0: summary += "There are signs of stress or exam pressure. "
    if score["sad"]>0: summary += "Some entries show sadness or emotional fatigue. "
    if score["anger"]>0: summary += "A few moments of frustration or irritation were noted. "
    if score["positive"]>0: summary += "You also showed hopeful or positive moments. "
    if summary == "": summary = "No strong emotional patterns detected. Keep journaling regularly."
    return summary

def current_user():
    return session.get("user")

# ---------------- Notification helper ----------------
def notify_counsellor(user: dict, message_text: str, counsellor_request_id: int = None):
    """
    Attempt to notify counsellor via SMTP and/or webhook.
    Returns a list of notification outcomes as dicts:
      [{"channel": "email", "success": True, "details": "..."}, ...]
    Records entries in notifications table.
    """
    outcomes = []

    # EMAIL notification if configured
    smtp_host = os.environ.get("SMTP_HOST")
    smtp_port = int(os.environ.get("SMTP_PORT", "587")) if os.environ.get("SMTP_PORT") else None
    smtp_user = os.environ.get("SMTP_USER")
    smtp_pass = os.environ.get("SMTP_PASS")
    counsellor_email = os.environ.get("COUNSELLOR_EMAIL")

    if smtp_host and smtp_port and smtp_user and smtp_pass and counsellor_email:
        try:
            subject = f"[SSRVM] Crisis alert â€” {user.get('name','Unknown')} (id={user.get('id')})"
            body = (
                f"Student: {user.get('name')} <{user.get('email')}>\n"
                f"User ID: {user.get('id')}\n"
                f"Time: {datetime.now(timezone.utc).isoformat()}\n\n"
                "Detected message:\n"
                f"{message_text}\n\n"
                "This message was automatically flagged as an urgent counsellor notification by SSRVM.\n"
                "Please follow your normal outreach/triage procedures right away."
            )
            msg = EmailMessage()
            msg["From"] = smtp_user
            msg["To"] = counsellor_email
            msg["Subject"] = subject
            msg.set_content(body)

            server = smtplib.SMTP(smtp_host, smtp_port, timeout=10)
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            server.quit()
            outcomes.append({"channel": "email", "success": True, "details": "email sent"})
        except Exception as e:
            outcomes.append({"channel": "email", "success": False, "details": str(e)})

    # WEBHOOK notification if configured
    webhook = os.environ.get("COUNSELLOR_WEBHOOK")
    if webhook:
        try:
            payload = {
                "text": f"SSRVM Crisis alert for student: {user.get('name')} (id={user.get('id')})",
                "student": {"id": user.get("id"), "name": user.get("name"), "email": user.get("email")},
                "message": message_text,
                "time": datetime.now(timezone.utc).isoformat()
            }
            resp = requests.post(webhook, json=payload, timeout=8)
            if 200 <= resp.status_code < 300:
                outcomes.append({"channel": "webhook", "success": True, "details": f"http {resp.status_code}"})
            else:
                outcomes.append({"channel": "webhook", "success": False, "details": f"http {resp.status_code}: {resp.text[:200]}"})
        except Exception as e:
            outcomes.append({"channel": "webhook", "success": False, "details": str(e)})

    # Persist notification attempts in notifications table
    try:
        conn = get_db()
        cur = conn.cursor()
        for o in outcomes:
            cur.execute(
                "INSERT INTO notifications (counsellor_request_id, user_id, channel, success, details) VALUES (?, ?, ?, ?, ?)",
                (counsellor_request_id, user.get("id"), o["channel"], 1 if o["success"] else 0, json.dumps(o["details"]) if isinstance(o["details"], (dict,list)) else str(o["details"]))
            )
        conn.commit()
        conn.close()
    except Exception:
        # do not raise; we want to continue even if logging fails
        pass

    return outcomes

# ---------------- Gemini integration (required for chatbot replies) ----------------
def analyze_with_gemini_generate(text: str):
    """
    Send text to Google Gemini (Generative) API and parse a JSON reply.
    Expected returned dict must contain at least: 'reply' (string).
    Also may include 'score' (float) and 'risk' (bool).
    Returns dict or None on failure.
    """
    try:
        import requests
    except Exception:
        return None

    api_key = os.environ.get("GEMINI_API_KEY")
    if not api_key:
        return None

    model = os.environ.get("GEMINI_MODEL", "text-bison-001")
    url = f"https://generativelanguage.googleapis.com/v1beta2/models/{model}:generate?key={api_key}"

    prompt = (
        "You are a warm, empathetic student-support assistant. Given the user's text, "
        "produce a JSON object ONLY (no explanation) with these fields:\n"
        "  - reply: the assistant's reply text (empathetic, supportive, concise)\n"
        "  - score: sentiment score between -1.0 and 1.0 (negative to positive)\n"
        "  - summary: one-line summary of detected feelings (optional)\n"
        "  - risk: true/false when self-harm/suicide risk is present\n"
        f"User text: '''{text}'''\n"
    )

    payload = {
        "prompt": {"text": prompt},
        "temperature": 0.0,
        "maxOutputTokens": 512,
    }
    headers = {"Content-Type": "application/json"}

    try:
        resp = requests.post(url, headers=headers, json=payload, timeout=15)
        if resp.status_code != 200:
            return None
        data = resp.json()

        # Extract textual content
        out = ""
        if isinstance(data, dict):
            if "candidates" in data and data["candidates"]:
                cand = data["candidates"][0]
                if isinstance(cand, dict):
                    out = cand.get("content") or cand.get("output") or ""
                else:
                    out = str(cand)
            elif "output" in data and isinstance(data["output"], list):
                parts = []
                for o in data["output"]:
                    if isinstance(o, dict) and "content" in o:
                        parts.append(o["content"])
                    else:
                        parts.append(str(o))
                out = "\n".join(parts)
            elif "text" in data:
                out = data["text"]
            else:
                out = json.dumps(data)
        else:
            out = str(data)

        # Find JSON object in output
        m = re.search(r"\{[\s\S]*\}", out)
        if m:
            parsed = json.loads(m.group(0))
            # normalize fields
            reply = str(parsed.get("reply", "")).strip()
            score = parsed.get("score", 0)
            try:
                score = float(score)
            except Exception:
                score = 0.0
            summary = str(parsed.get("summary", "")).strip() if parsed.get("summary") is not None else ""
            risk = bool(parsed.get("risk", False))
            return {"reply": reply, "score": score, "summary": summary, "risk": risk, "raw": parsed}

        # Fallback: line-parsing
        reply = ""
        score = None
        summary = ""
        risk = False
        for line in out.splitlines():
            if ":" in line:
                k, v = line.split(":", 1)
                k = k.strip().lower(); v = v.strip()
                if k == "reply" and not reply:
                    reply = v
                if k == "score" and score is None:
                    try:
                        score = float(re.findall(r"-?\d+\.?\d*", v)[0])
                    except Exception:
                        pass
                if k == "summary" and not summary:
                    summary = v
                if k == "risk":
                    risk = ("true" in v.lower()) or ("yes" in v.lower())
        if not reply and out.strip():
            reply = out.strip()
        if score is None:
            score = 0.0
        if not reply:
            return None
        return {"reply": reply, "score": float(score), "summary": summary, "risk": bool(risk), "raw": data}
    except Exception:
        return None

# ---------------- Local mentor (kept for other uses, not used for chat replies) ----------------
def mentor_reply(text: str):
    t = (text or "").strip()
    if not t:
        return ("I'm here for you. Tell me what's on your mind, I'm listening.", False)
    lower = t.lower()
    if "exam" in lower or "test" in lower:
        return ("Exam pressure is heavy. Try 25â€“5 study timer and plan your next tiny step.", True)
    if "panic" in lower or "anxiety" in lower:
        return ("Try 4â€“4â€“4 breathing: inhale 4s, hold 4s, exhale 4s. It really helps. I'm here.", True)
    if "lonely" in lower or "alone" in lower:
        return ("Feeling lonely is difficult. Try messaging someone you trustâ€”even a small hello helps.", True)
    score = quick_sentiment(lower)
    if score < 0:
        return ("Thanks for telling me. I can help break this down into steps. Want counsellor support too?", True)
    return ("Got it. I can help with grounding or focus tools anytime.", False)

# ---------------- Immediate crisis phrases ----------------
CRISIS_PHRASES = ["kill myself","suicide","hurt myself","self harm","end my life","can't continue","want to die"]

# ---------------- Routes: pages, auth, etc. ----------------
@app.route("/")
def index():
    return render_template("index.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/signup", methods=["GET","POST"])
def signup():
    if request.method == "POST":
        name = request.form.get("name","").strip()
        email = request.form.get("email","").strip().lower()
        password = request.form.get("password","")
        if not (name and email and password):
            flash("Please fill all fields.")
            return redirect(url_for("signup"))
        conn = get_db(); cur = conn.cursor()
        try:
            cur.execute("INSERT INTO users(name,email,password) VALUES (?,?,?)", (name,email,password))
            conn.commit()
        except sqlite3.IntegrityError:
            conn.close(); flash("Email already exists."); return redirect(url_for("signup"))
        cur.execute("SELECT id,name,email FROM users WHERE email=?", (email,)); u = cur.fetchone(); conn.close()
        session["user"] = u
        return redirect(url_for("dashboard"))
    return render_template("signup.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/login", methods=["GET","POST"])
def login():
    if request.method == "POST":
        email = request.form.get("email","").strip().lower(); password = request.form.get("password","")
        if email=="admin@ssrvm.com" and password=="admin123":
            session["user"] = {"id":0,"name":"Admin","email":"admin@ssrvm.com"}; return redirect(url_for("admin"))
        conn = get_db(); cur = conn.cursor()
        cur.execute("SELECT id,name,email,password FROM users WHERE email=?", (email,)); u = cur.fetchone(); conn.close()
        if not u or u["password"] != password:
            flash("Invalid credentials."); return redirect(url_for("login"))
        session["user"] = {k: u[k] for k in ("id","name","email")}
        return redirect(url_for("dashboard"))
    return render_template("login.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/logout")
def logout():
    session.clear(); flash("Logged out."); return redirect(url_for("index"))

@app.route("/dashboard")
def dashboard():
    if not current_user(): return redirect(url_for("login"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT want_counsellor, created_at FROM counsellor_requests WHERE user_id=? ORDER BY id DESC LIMIT 1", (current_user()["id"],))
    c_req = cur.fetchone(); conn.close()
    return render_template("dashboard.html", app_name=APP_NAME, counsellor_request=c_req,
                           prompt=random.choice(PROMPTS), quote=random.choice(QUOTES),
                           emotion_summary=emotion_summary(current_user()["id"]), year=datetime.now().year)

@app.route("/journal", methods=["GET","POST"])
def journal():
    if not current_user(): return redirect(url_for("login"))
    if request.method=="POST":
        content = request.form.get("content","").strip()
        if not content: flash("Write something."); return redirect(url_for("journal"))
        conn = get_db(); cur = conn.cursor()
        cur.execute("INSERT INTO journals(user_id,content) VALUES (?,?)", (current_user()["id"], content)); conn.commit(); conn.close()
        flash("Saved."); return redirect(url_for("journal"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT content,created_at FROM journals WHERE user_id=? ORDER BY id DESC LIMIT 20", (current_user()["id"],))
    entries = cur.fetchall(); conn.close()
    return render_template("journal.html", entries=entries, prompt=random.choice(PROMPTS), app_name=APP_NAME, year=datetime.now().year)

@app.route("/cbt", methods=["GET","POST"])
def cbt():
    if not current_user(): return redirect(url_for("login"))
    reframe = None
    if request.method=="POST":
        thought = request.form.get("thought","")
        def cbt_reframe(th):
            t = (th or "").lower()
            if not t: return "Describe the thought. Example: 'I always fail exams.'"
            patterns = [("always","Is it *always*? Look for exceptions."), ("never","Even one example shows it's not 'never'."), ("should","Try replacing 'should' with a kinder expectation."), ("must","Is this a preference instead of a strict rule?"), ("fail","One failure doesn't define your worth."), ("alone","Consider reaching out to someone trusted.")]
            for key,msg in patterns:
                if key in t: return f"It sounds tough. {msg} Try a softer reframe: 'I'm improving step by step.'"
            return "Try listing evidence for and against the thought. Balance helps."
        reframe = cbt_reframe(thought)
    return render_template("cbt.html", reframe=reframe, app_name=APP_NAME, year=datetime.now().year)

@app.route("/resources")
def resources():
    return render_template("resources.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/grounding")
def grounding():
    return render_template("grounding.html", app_name=APP_NAME, year=datetime.now().year)

@app.route("/profile")
def profile():
    if not current_user(): return redirect(url_for("login"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT message,want_counsellor,created_at FROM counsellor_requests WHERE user_id=? ORDER BY id DESC", (current_user()["id"],))
    reqs = cur.fetchall(); conn.close()
    return render_template("profile.html", app_name=APP_NAME, requests=reqs, year=datetime.now().year)

@app.route("/export-journal", methods=["POST"])
def export_journal():
    if not current_user(): return redirect(url_for("login"))
    conn = get_db(); cur = conn.cursor()
    cur.execute("SELECT created_at, content FROM journals WHERE user_id=?", (current_user()["id"],))
    rows = cur.fetchall(); conn.close()
    out_path = os.path.join(DATA_DIR, f"journal_{current_user()['id']}.csv")
    with open(out_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f); writer.writerow(["created_at","content"])
        for r in rows: writer.writerow([r["created_at"], r["content"]])
    return send_file(out_path, as_attachment=True)

@app.route("/delete-account", methods=["POST"])
def delete_account():
    if not current_user(): return redirect(url_for("login"))
    uid = current_user()["id"]
    conn = get_db(); cur = conn.cursor()
    cur.execute("DELETE FROM journals WHERE user_id=?", (uid,))
    cur.execute("DELETE FROM counsellor_requests WHERE user_id=?", (uid,))
    cur.execute("DELETE FROM users WHERE id=?", (uid,))
    conn.commit(); conn.close(); session.clear(); flash("Account deleted.")
    return redirect(url_for("index"))

# ---------------- Chat endpoints (Gemini-driven replies + automatic notification on crisis) ----------------
@app.route("/chat")
def chat_page():
    if not current_user(): 
        return redirect(url_for("login"))
    return render_template("chatbot.html", app_name=APP_NAME, year=datetime.now().year)

# ðŸ‘‡ Add this one line immediately after
app.add_url_rule('/chat', endpoint='chatbot', view_func=chat_page)

@app.route("/api/chatbot", methods=["POST"])
def api_chatbot():
    if not current_user(): 
        return jsonify({"error":"unauthorized"}), 401

    data = request.get_json() or {}
    text = (data.get("text","") or "").strip().lower()

    # ---------------- CRISIS PHRASE DETECTION ----------------
    if any(p in text for p in CRISIS_PHRASES):
        # Log counsellor request
        try:
            conn = get_db()
            cur = conn.cursor()
            cur.execute("INSERT INTO counsellor_requests (user_id, message, want_counsellor) VALUES (?, ?, ?)",
                        (current_user()["id"], text, 1))
            counsellor_request_id = cur.lastrowid
            conn.commit()
            conn.close()
        except Exception:
            counsellor_request_id = None

        # Notify counsellor automatically
        notify_outcomes = notify_counsellor(current_user(), text, counsellor_request_id)

        # Crisis response
        reply_text = (
            "It sounds like youâ€™re in serious distress. Please talk to someone you trust or reach out to your counsellor immediately. "
            "You are not alone â€” your counsellor/student support team has been notified and will reach out soon. "
            "If youâ€™re in immediate danger, please contact local emergency services right away."
        )

        resp = {
            "reply": reply_text,
            "crisis": True,
            "notified": any(o.get("success") for o in notify_outcomes)
        }
        if os.environ.get("SSRVM_DEBUG_NOTIFY") == "1":
            resp["notify_debug"] = notify_outcomes
        return jsonify(resp), 200

    # ---------------- DISTRESS / NEGATIVE EMOTION DETECTION ----------------
    distress_keywords = [
        "stress", "stressed", "anxious", "panic", "hopeless", "sad",
        "depressed", "overwhelmed", "guilty", "ashamed", "angry", 
        "lonely", "tired", "exhausted", "worthless", "fear", "worry",
        "uneasy", "scared", "pressure", "burnout"
    ]

    if any(word in text for word in distress_keywords):
        coping_suggestions = [
            "Try 4â€“4â€“4 breathing â€” inhale 4s, hold 4s, exhale 4s.",
            "Write your feelings in your journal. It often helps you understand your emotions.",
            "Take a short walk, drink some water, or listen to calming music.",
            "Reach out to someone you trust â€” even a small chat can make a difference.",
            "Remember to take things one step at a time. Youâ€™re doing your best."
        ]

        reply_text = (
            random.choice(coping_suggestions)
            + " Would you like me to notify a counsellor so they can reach out to support you?"
        )

        return jsonify({
            "reply": reply_text,
            "ask_counsellor": True,
            "crisis": False
        }), 200

    # ---------------- NORMAL GEMINI CHAT ----------------
    g = analyze_with_gemini_generate(text)
    if g is None:
        return jsonify({
            "reply": "I'm still here for you â€” tell me whatâ€™s been on your mind. The assistant service is temporarily unavailable, but you can keep sharing how you feel.",
            "error": "gemini_unavailable"
        }), 503

    reply = g.get("reply", "").strip() or "I'm here â€” tell me more."
    score = float(g.get("score", 0))
    risk = bool(g.get("risk", False))
    summary = g.get("summary", "") or ""

    response = {
        "reply": reply,
        "ask_counsellor": False,
        "summary": summary,
        "score": score,
        "risk": risk
    }

    if risk or score < -0.3:
        response["ask_counsellor"] = True

    return jsonify(response), 200

@app.route("/api/counsellor-request", methods=["POST"])
def api_counsellor_request():
    if not current_user(): return jsonify({"error":"unauthorized"}), 401
    data = request.get_json() or {}
    want = 1 if data.get("want") else 0
    note = (data.get("note") or "").strip()
    conn = get_db(); cur = conn.cursor()
    cur.execute("INSERT INTO counsellor_requests(user_id,message,want_counsellor) VALUES (?,?,?)",
                (current_user()["id"], note, want)); conn.commit(); conn.close()
    return jsonify({"ok": True})

# ---------------- Admin ----------------
@app.route("/admin")
def admin():
    if not current_user(): return redirect(url_for("login"))
    if current_user().get("email") != "admin@ssrvm.com": return "Access denied", 403
    conn = get_db(); cur = conn.cursor()
    cur.execute("""SELECT users.name, users.email, counsellor_requests.message, counsellor_requests.want_counsellor, counsellor_requests.created_at
                   FROM counsellor_requests JOIN users ON users.id=counsellor_requests.user_id
                   ORDER BY counsellor_requests.id DESC""")
    rows = cur.fetchall(); conn.close()
    return render_template("admin.html", rows=rows, app_name=APP_NAME, year=datetime.now().year)

@app.context_processor
def inject_globals():
    return {"app_name": APP_NAME}

# ---------------- Run ----------------
if __name__ == "__main__":
    import os
    port = int(os.environ.get("PORT", 10000))
    app.run(host="0.0.0.0", port=port, debug=True)

